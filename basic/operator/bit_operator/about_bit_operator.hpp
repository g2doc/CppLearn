//
//  about_bit_operator.hpp
//  CppLearn
//
//  Created by 张昊 on 2022/11/4.
//

#ifndef about_bit_operator_hpp
#define about_bit_operator_hpp

#include <stdio.h>

/** 原码, 反码 和 补码
 原码: 一个整数直接转换成 2 进制数, 就是其对应的原码
 e.g.
 单字节的 5 的原码: 0000 0101
 -5 的原码: 1000 0101
 
 反码: 正数的反码 就是 其原码
      负数的反码  是将原码中 除了最高位符号位之外的每一位取反
 e.g.
 5 的反码 0000 0101
 -5 的反码 1000 0101 => 1111 1010
 
 补码:
    正数的补码就是 其原码
    负数的 补码 = 反码 + 1
 e.g.
 5 的补码 0000 0101 => 0000 0101
 -5 的补码
    1000 0101 => 反码 1111 1010 => 补码 1111 1011
 */


/** @为什么计算机要使用 补码 来表示负数并参与运算呢 ?
 >1.表示范围:
    单字节整数(char) 来看 =>
    无符号型: unsigned char 表示范围是 [0, 255] 2^8 , 1 byte = 8 bit, 每一 bit 有 2 个数字可选
 所以范围是: 2^8 = 256, 从 0 起, 所以是 [0, 255]
        0 表示 0000 0000
        255 表示 1111 1111
    -----------------------------------------------------------------------------
    有符号型: [-128, 127]
        0 表示 0000 0000
        因为有符号, 所以应该还有一个 负0, 虽然值也是0, 表示为 1000 0000
    127: 1111 1111
    -127: 1111 1111 -> 取反码: 1000 0000 -> 取补码: 1000 0001
    
    -128 呢 ?
    无法通过原码 表示 -128, 而我们却有 2 个0
    如果把其中 1 个 0 指定为 -128 ?
    存在的问题是 0 和 -127 的跨度过大, 硬件运算时不方便
 
    ===> 所以在计算机中, 负数采用补码表示,  原码表示不出来
    
    单字节有符号整型 char 的 -1 表示为: 0000 0001 => 1111 1110 => 1111 1111
    -127:
    原码 1111 1111 => 1000 0000 => 1000 0001
    -128:
    原码表示不出来, 除了符号位, 最大的数只能是 127,  所以其在计算机中表示为 1000 0000
    因为 -127 是 1000 0001,  1000 0001 - 1 = 1000 0000 表示 -128
    nice ...
 
    
>2. 大小的习惯:
    从数据大小上来理解, 单字节有符号数, 正数范围: [1, 127],
    最大 127, 不考虑符号位是 1111 1111
    最小 1, 不考虑符号位是 0000 0001
    
    负数最大的 -1, 1111 1111, 其中 111 1111 表示其数值部分
        后面的数据依次 -1, 减小到 000 0001 的时候, 就用 1000 0001 表示 -127 了
    -127 再减去 1, 数值部分就变成了 000 0000, 但是还有一个符号位,
    所以有两个数值为 000 0000 的 0, 其中带符号的 1000 0000 刚好可以用来表示 -128
    
 >3. 计算机运算方面的原因:
    >负数的补码, 与其对应正数的补码之间的转换 可以用同一种方法, 求补来完成: (简化硬件)
    -127 => 127
    1000 0001 原码 => 0111 1110 反码 => 0111 1111 补码
 
    127 => -127
    1111 1111 原码 =>
 
    
 
 对一个正数的原码 取反 + 1 得到 该正数对应的负数的 补码
 ~6 = -7
 -6: 1000 0110 对应补码: 1111 1010
 
 
 */



/** 位或运算 ｜
 两个操作数中存在 1, 则结果为 1
 位或运算可以理解为 没有进位的加法
 
 1<<16 = 65536
 
 0000 0000 0000 0001 0000 0000 0000 0000
 
 */

#include <cstdlib>
#include <cstring>
#include <cstdio>

void test_bit_or_operator(){
    
    // printf("1 << 16 = %d \r\n", s);
}



/** 位与运算 &
 概念:
    参与运算的 2 个对象, 按照 2 进制位进行 与 运算,
    负数需要以 补码形式 参与位与运算
 
 */

#endif /* about_bit_operator_hpp */
