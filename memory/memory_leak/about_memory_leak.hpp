//
//  about_memory_leak.hpp
//  CppLearn
//
//  Created by 张昊 on 2022/11/4.
//

#ifndef about_memory_leak_hpp
#define about_memory_leak_hpp

#include <stdio.h>
/** 内存泄露
 C/C++ 中, 内存的分配和回收都是开发人员编写代码时主动完成的:
    优点: 内存管理的开销小, 程序拥有很高的执行效率
    
    缺点: 比较依赖开发者的水平, 随着代码规模的扩大, 很容易遗忘释放内存的步骤, 或者是一些不规范的变成会使得程序具有安全隐患,
    如果对内存管理不当 => 会导致程序中存在内存缺陷, 甚至在运行时产生 内存故障错误
 
 当动态分配的内存在 程序结束之前没有被回收时, 则发生了内存泄露,
 由于系统软件, 如: 操作系统, 编译器, 开发环境等都是由 C/C++ 实现等, 所以不可避免的存在内存泄露缺陷
 特别是一些在服务器上长期运行的软件, if 存在内存泄露则会造成严重后果, 如: 性能下降, 程序终止, 系统崩溃, 无法提供服务等,,
 
 e.g.
 当程序申请了内存, 但是不进行归还, 久而久之, 可用内存就会越来越少, os 进行自我保护, 从而杀掉该进程, 这就是 OOM(out of memory)
 
 内存泄露分为以下 2 类:
    1. 堆内存泄露
    平时常说的内存泄露多指 堆内存泄露, 在堆上申请了资源, 在结束使用的时候, 没有释放归还给 os, 从而导致这块内存永远不会被再次使用 (除了重启)
 
    2. 资源泄露
    通常指的是系统资源, 比如 socket, 文件描述符 fd 等, 因为这些在系统中都是有限制的, 如果创建了而不进行归还, 久而久之, 就会耗尽资源, => 导致其他程序不可用

 
 内存泄露的根源, root cause:
    内存泄露主要指的是在堆 heap 上申请的动态内存泄露, 或者说是指针指向的内存块 忘了被释放, 导致该块内存不能再次被重新申请使用.
 
 换句话讲, 内存泄露的原因一定是因为指针, 指针是 C 的精髓, 或者说 内存管理是 C 的精髓
 
 C/C++ 可以直接和 os 交互, 开发者可以根据自己的实际使用场景灵活的进行内存的分配和释放,
 
 */


/** 为什么 C/C++ 存在指针 - 进程的内存布局
 
 以 32位 os 的进程内存布局为例:
 [高地址]
 |----------------------|
 | kernel space         |   1 GB
 |----------------------|------------------------------------------------------ user mode space
 |  stack               | 栈空间, 向下增长
 |    |                 |
 |   \|/                |
 |----------------------|
 |                      | 未分配区域, 可用于 堆和栈的增长
 |                      |
 |----------------------|
 |    /|\               |
 |     |                |
 |    heap              | 堆空间, 向上增长
 |----------------------|
 | bss                  | 未初始化的的数据段, 存放未初始化的数据
 |----------------------|
 | data segment         | 数据段, 存放 已经初始化的数据, 全局 和 静态变量，
 |                      | 进程启动时就初始化,  此处代码不可执行, 可修改
 |----------------------|
 | text segment         | 文本段, 存放字面量值,
 |                      | 进程启动时就初始化,  此处代码不可执行, 只读
 |----------------------|
 | code segment         | 包含编译之后的 机器码指令, 进程启动时就初始化, 可执行, 只读
 |----------------------|-------------------------------------------------------------------------
 | bios                 | 基本输入输出, 主板的基本输入输出程序
 |----------------------|
 [低地址]
 
 */

/** 栈
 连续内存块
 编译器在编译时就已经知道要分配的内存大小, 当调用函数的时候, 其内部变量都会在栈上分配内存
 当结束函数调用的时候, 内部变量就会被释放,  => 进而将内存归还给栈
 e.g.
 class Test{};
 void func(){Test t;}
 
 t 对象就是在栈上进行分配, 当出了 func 函数的作用域时, 就会自动调用 t 的析构函数对其进行释放
 
 先进后出
 
 栈上的内存分配和释放, 是一个进栈和出栈的过程(只对应编译器的一个指令), => 所以相对于堆上的内存分配
 栈要更快
 
 缺点:
    每个线程都有自己的栈, 栈上的对象 不可以垮线程访问
    这就决定了栈空间的大小是有限制的, 如果栈空间过大会多线程会很快耗光 RAM
 
 查看 栈大小
 zhanghao@zhanghaodeAir ~ % ulimit -s
 8176
 
 在我的笔记本上是接近 8MB
 
 修改栈大小: ulimit -s {val}
 */



/** 堆
 heap 是一种内存管理方式
 堆的内存管理方式的特点就是: 自由(随时申请, 释放, 大小块随意)
 
 堆内存是操作系统 os 划归给 堆管理器(操作系统中的一段代码, 属于 os 的内存管理单元) 来进行管理
 
 堆管理器提供了对应的接口: _sbrk   _mmap 等
 该接口往往由 运行时库 (linux 上为 glibc ) 进行调用
 也可以说是 运行时库来进行 堆内存管理, 提供了 malloc/free 等函数供开发人员调用, 进而使用堆内存
 
 由于是在运行期间进行内存分配, 分配堆大小也是在运行时期才知道, => 所以堆只支持动态分配
 
 内存堆申请和释放都由 开发者手动操作, 所以容易导致内存泄露
 
 特点:
    1. 变量可以在进程范围内进行访问, 进程内的所有线程都可以访问该变量
    2. 没有内存大小限制(只是相对于 栈而言), 最终也会受限制于 RAM
    3. 相对于栈来讲 访问速度较慢
    4. 存在内存碎片
    5. 开发者管理内存的申请和释放
 
 */



/** 静态分配 & 动态分配
 静态分配由编译器完成
    局部变量 和 函数传参, 都是在编译器就分配好了
 void func(){
    int a[10];
 }
 a 占 10 * sizeof(int) 个字节, 在编译器就计算好了, 运行的时候直接 进栈出栈
 
 
 动态分配
 动态分配也不都是在堆上的, 在栈上也支持动态分配
 1. 栈动态分配:
    alloca() 分配,  编译器自动进行释放
    分配速度快, 分配大小由编译器在 编译期完成
    不会产生内存碎片, => 栈内存分配是连续的, 先入先出 FIFO
    大小受限制, 栈的大小依赖于 os
    访问受限制, 只能在 当前函数 or 作用域内 进行访问
 2.
 */


/** 内存泄露分类
 1. 常发性内存泄露 => 产生内存泄露的代码或函数 每次执行代码都会产生内存泄露
 2. 偶发性内存泄露
 3. 一次性内存泄露 => 在程序的生命周期内只会泄露一次
 4. 隐式内存泄露 =>
    程序在运行过程中不断的分配内存, 但是知道程序结束时才释放内存,
    虽然看上去没有内存泄露, 因为最终都释放了所有申请的内存
    but
    如果该服务运行时间久, 长时间不及时释放内存也可能会导致最终耗尽系统的所有内存造成泄露
 常见的隐式内存泄露:
    >内存碎片
    >调用了 free/delete 却没有将内存归还给 os
    >STL 中的 vector.clear() 内存并不会直接归还给 os, 而是放回 allocator, 按照内部策略返回给 os
 
 Test* t = new Test;
 free(t);
 
 内存泄露 !
 free 释放内存并没有调用 Test 的析构函数释放 Test 的成员变量
 
 Test* t = new Test[10];
 delete t;
 
 内存泄露 !
 调用了 10 次构造只有 1 次析构
 => 应该是: delete []t;
 
 
 派生类对象在创建时构造函数调用顺序:
 1. 调用父类构造
 2. 调用父类成员变量的 构造
 3. 调用派生类自身的构造
 
 析构顺序:
 1. 派生类析构
 2. 派生类成员变量的析构
 3. 派生类父类的析构

 
 */




#endif /* about_memory_leak_hpp */
